<html>
  <head>
    <title>My first Three.js app</title>
    <style>
      body { margin: 0; }
      canvas { width: 100%; height: 100% }
      #info {
        position: absolute;
        top: 0;
        right: 0;
        z-index: 1000;
        color: white;
      }
    </style>

    <script src="http://cdnjs.cloudflare.com/ajax/libs/three.js/r69/three.min.js"></script>
    <script src="https://code.jquery.com/jquery-2.1.1.min.js"></script>
    
    <script type="text/javascript">
      var _gaq = _gaq || [];
      _gaq.push(['_setAccount', 'UA-46659221-1']);
      _gaq.push(['_trackPageview']);

      (function() {
        var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
        ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
        var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
      })();
    </script>

  </head>
  <body>


    <script>

      function Cell(x,y) {
        this.x = x;
        this.y = y;
      }

      Cell.prototype.neighbours = function(){
        if (this.calculatedNeighbours) {
          return this.calculatedNeighbours;
        }

        this.calculatedNeighbours = [
            new Cell(this.x-1,this.y-1),
            new Cell(this.x,this.y-1),
            new Cell(this.x+1,this.y-1),

            new Cell(this.x-1,this.y),
            new Cell(this.x+1,this.y),

            new Cell(this.x-1,this.y+1),
            new Cell(this.x,this.y+1),
            new Cell(this.x+1,this.y+1),
          ];
        return this.calculatedNeighbours;
      };    

      Cell.prototype.isSameAs = function(other) {
        return this.x == other.x && this.y == other.y;
      }

      Cell.prototype.object3d = function(geometry, material) {
          if (this.cube) {
            return this.cube;
          }
          var c = new THREE.Mesh( geometry, material );
          c.position.x = this.x;
          c.position.y = this.y;
          this.cube = c;
          return c;
      }

      var getCandidates = function(cells) {
        var index, i;
        var candidates = [];

        for (index = 0; index < cells.length; ++index) {
          candidates.push(cells[index]);
          candidates = candidates.concat(cells[index].neighbours());
        }
        
        var filtered = [];

        // console.log("candidates", candidates);    

        var seenAlready = false;

        for (index = 0; index < candidates.length; ++index) {
          for (i = 0; i < filtered.length; ++i) {
            if (filtered[i].isSameAs(candidates[index])) {
              seenAlready = true;
            }
          }

          if (!seenAlready) {
            filtered.push(candidates[index]);
          }
          seenAlready = false;
        }

        // console.log("filtered", filtered);

        return filtered;
      }

      var wasAlive = function(cell, aliveCells) {
        var i;
        for (i = 0; i < aliveCells.length; ++i) {
           if (aliveCells[i].isSameAs(cell)) {
            return true;
           }   
          }
        return false;
      }
      
      var nextGeneration = function(cells) {

      
        var index;
      
        var candidates = getCandidates(cells);
        
        var nextGenerationCells = [];

        for (index = 0; index < candidates.length; ++index) {
          var numberOfNeighbours = 0;

          var i;

          var aroundCell = candidates[index].neighbours();

          for (i = 0; i < cells.length; ++i) {
           var j;
           for (j = 0; j < aroundCell.length; ++j) {
            if(cells[i].isSameAs(aroundCell[j])) {
              numberOfNeighbours = numberOfNeighbours + 1;            
            }

           }
          }

          if ( numberOfNeighbours == 3 || (numberOfNeighbours == 2 && wasAlive(candidates[index], cells))) {
            nextGenerationCells.push(candidates[index]);
          } 
        }

        nextGenerationCells.push(new Cell(Math.floor((Math.random() * 60) + 1), Math.floor((Math.random() * 60) + 1)));
        nextGenerationCells.push(new Cell(Math.floor((Math.random() * 60) + 1), Math.floor((Math.random() * 60) + 1)));
        nextGenerationCells.push(new Cell(Math.floor((Math.random() * 60) + 1), Math.floor((Math.random() * 60) + 1)));
        
        
        return nextGenerationCells;
      };

      var Blinker = function(x,y) {
        return [
        new Cell(x,y),
        new Cell(x+1,y),
        new Cell(x+2,y),
        ];
      }

      var Glider = function(x,y) {
        return[
          new Cell(x,y+1),
          new Cell(x+2,y),
          new Cell(x+2,y+1),
          new Cell(x+2,y+2),
          new Cell(x+1,y+2),
        ];
      }
      var cells = [
      ].concat(Glider(0,0)).concat(Glider(20,-9)).concat(Glider(10,-9)).concat(Blinker(7,1)).concat(Blinker(17,11));

      var scene = new THREE.Scene();
      var camera = new THREE.PerspectiveCamera( 75, window.innerWidth/window.innerHeight, 0.1, 1000 );

      var renderer = new THREE.WebGLRenderer();
      renderer.setSize( window.innerWidth, window.innerHeight );
      document.body.appendChild( renderer.domElement );

      var geometry = new THREE.BoxGeometry( 1, 1, 1 );
      var material = new THREE.MeshBasicMaterial( { color: 0x00ff00 } );

      camera.position.z = 15;

      var camera_z_direction = 0.3;

      var render = function () {
        var obj, i;
        for ( i = scene.children.length - 1; i >= 0 ; i -- ) {
            obj = scene.children[ i ];
            if (obj !== camera) {
                scene.remove(obj);
            }
        };

        var index;

        cells = nextGeneration(cells);

        $("#numberOfCells").text(cells.length);

        for (index = 0; index < cells.length; ++index) {
          
          // cube.position.z = Math.floor((Math.random() * 5) + 1);
          scene.add( cells[index].object3d(geometry, material) );            
        }

        // cube.rotation.x += 0.1;
        // cube.rotation.y += 0.1;

        // cube.position.x = cube.position.x + 1;
        // cube.position.y = cube.position.y + 1;

        camera.rotation.z += 0.01;

        // camera.rotation.x += 1;
        camera.position.z += camera_z_direction;

        if (camera.position.z > 150 || camera.position.z < 15) {
          camera_z_direction = -camera_z_direction;
        }

        renderer.render(scene, camera);
        requestAnimationFrame( render );
        // setTimeout(function(){
          
        // }, 50);
        
      };

      render();
    </script>

  <div id="info">
    Game of life by @dziemid
    <div>
      Number of cells: <span id="numberOfCells">???</span>
    </div>
  </div>  
  </body>
</html>